/* =============================================== *
 *                                                 *
 * knight.bminor                                   *
 *                                                 *
 *                                                 *
 * =============================================== */

N: integer = 5; // tamaño del tablero

index: function integer (x: integer, y:integer) = {
	return x * N + y;
}

// Función auxiliar para imprimir el tablero
print_board: function void (board: array [] integer) = {
	x: integer;
	y: integer;
	
	for(x = 0; x < N; x++) {
		for(y = 0; y < N; y++) {
			if (x % 2 == y % 2) {
				print " ", board[index(x,y)];
			}
 		}
		print "\n";
	}
}

// funcion auxiliar para validar si un movto es valido
can_move: function boolean (x:integer, y:integer, board: array [] integer) = {
	return x >= 0 && x < N && y >= 0 && y < N && board[index(x,y)] == 0;
}

// Funcion recursiva para recorrer el caballo el tablero
walk: function boolean (x: integer, y: integer, m: integer, board: array [] integer, xmoves: array [] integer, ymoves: array [] integer) = {
	i: integer = 0;
	
	board[index(x, y)] = m;  // ← AGREGAR ESTA LÍNEA AL INICIO
	
	if (m == N * N) {
		print_board(board);
		return true;
	}
	
	for (i = 0; i < array_length(xmoves); i++) {
		next_x: integer = x + xmoves[i];
		next_y: integer = y + ymoves[i];
		if (can_move(next_x, next_y, board)) {
			board[index(next_x, next_y)] = m + 1;
			if (walk(next_x, next_y, m+1, board, xmoves, ymoves)) {
				return true;
			}
			board[index(next_x, next_y)] = 0;  // ← CAMBIAR -1 por 0
		}
	}
	return false;
}


main: function void () = {
	board: array [N*N] integer;
	
	xmoves: array [N] integer = {2, 1, -1, -2, -2, -1, 1, 2};
	ymoves: array [N] integer = {1, 2, 2, 1, -1, -2, -2, -1};
	
	if (walk(0, 0, 1, board, xmoves, ymoves)) {
		print "Solucion encontrada!\n";
	} else {
		print "No existe solucion!\n";
	}

}
